// PandaZoom.cpp : Implementation of CPandaZoom
#include "stdafx.h"
#include "PDXTrans.h"
#include "PandaZoom.h"

//--- Local
static WCHAR g_Notice[] = L"Copyright Pandasoft Computer Systems 2000, Unauthorized duplication of this string is illegal {AF279B30-86EB-11D1-81BF-0000F87557DB}";
void AndyTrace(LPCTSTR lpszFormat, ...);
/////////////////////////////////////////////////////////////////////////////
// CPandaZoom

HRESULT CPandaZoom::FinalConstruct()
{
	HRESULT hRes;
    //--- Uncomment this when debugging to allow only
    //    one thread to execute the work proc at a time
     m_ulMaxImageBands = 1;

    //--- Init base class variables to control setup
    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 1;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 3.0;

    //--- Init data
    m_bCopyrightIsNotValid = ( _LICENSED_VERSION )?( false ):( true );
    m_eZoomStyle        = DXZS_IN;
//    m_InputSize.cx      = 0;
//    m_InputSize.cy      = 0;

    m_bRequiresSave = FALSE;
	m_nNumInputs = 0;
	//Create the Transform Factory.IDXTransformFactory* pTransFact;
	hRes = CoCreateInstance( CLSID_DXTransformFactory, NULL,
				 CLSCTX_INPROC, IID_IDXTransformFactory,
				 (void **)&m_pTransFact );//Create the transform.
	if(FAILED(hRes))
	{
		return hRes;
	}

	return CoCreateFreeThreadedMarshaler(
		GetControllingUnknown(), &m_pUnkMarshaler.p);
}


void CPandaZoom::FinalRelease()
{
	SAFE_RELEASE(m_pTransFact);
	m_pUnkMarshaler.Release();
}





/*****************************************************************************
* CPandaZoom::get_ZoomStyle *
*-------------------------*
*   Description:
*       This method is used to get the current wipe style.
*-----------------------------------------------------------------------------
*   Created By: EDC                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CPandaZoom::get_ZoomStyle( DXZOOMSTYLE *pVal )
{
    HRESULT hr = S_OK;
    if( !pVal )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_eZoomStyle;
    }
    return hr;
} /* CPandaZoom::get_ZoomStyle */

/*****************************************************************************
* CPandaZoom::put_ZoomStyle *
*-------------------------*
*   Description:
*       This method is used to get the size of the transition area between
*   image A and image B.
*-----------------------------------------------------------------------------
*   Created By: EDC                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CPandaZoom::put_ZoomStyle( DXZOOMSTYLE newVal )
{
    m_eZoomStyle = newVal;
    return S_OK;
} /* CPandaZoom::put_ZoomStyle */


/*****************************************************************************
* CPandaZoom::get_Copyright *
*-------------------------*
*   Description:
*       This method is used to get the copyright notice from the vendor of
*   this transform.
*-----------------------------------------------------------------------------
*   Created By: EDC                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CPandaZoom::get_Copyright( BSTR *pVal )
{
    HRESULT hr = S_OK;

    if( _LICENSED_VERSION )
    {
        if( DXIsBadWritePtr( pVal, sizeof( *pVal ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            *pVal = SysAllocString( g_Notice );
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
} /* CPandaZoom::get_Copyright */

/*****************************************************************************
* CPandaZoom::put_Copyright *
*-------------------------*
*   Description:
*       This method is used to compare the copyright notice being passed in
*   with the one generated by the object. The free consumer version does not
*   persist it's properties, but the licensed version does.
*-----------------------------------------------------------------------------
*   Created By: EDC                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CPandaZoom::put_Copyright( BSTR newVal )
{
    HRESULT hr = E_INVALIDARG;

    if( !wcscmp(g_Notice, newVal) )
    {
        hr = S_OK;
        m_bCopyrightIsNotValid = false;
    }
    return hr;
} /* CPandaZoom::put_Copyright */



HRESULT CPandaZoom::OnSetup( DWORD dwFlags )
{
    HRESULT hr = S_OK;


	if (HaveInput(1))
		m_nNumInputs = 2;
	else 
		m_nNumInputs = 1;
/*    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {

    }
    */return hr;
} /* CPandaZoom::OnSetup */

/*	AndyTrace("Position Output x1=%d , y1=%d , x2=%d , y2=%d \n",
		WI.OutputBnds.Left(), WI.OutputBnds.Top(), WI.OutputBnds.Right(), WI.OutputBnds.Bottom());
	AndyTrace("Position DoBnds x1=%d , y1=%d , x2=%d , y2=%d \n",
		WI.DoBnds.Left(), WI.DoBnds.Top(), WI.DoBnds.Right(), WI.DoBnds.Bottom());
	AndyTrace("Position newBnds x1=%d , y1=%d , x2=%d , y2=%d \n\n",
		newbnd.Left(), newbnd.Top(), newbnd.Right(), newbnd.Bottom());
*/

HRESULT CPandaZoom::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;
	IDXSurface*	pInSurf = NULL;

	// Work out the size parts with regard to the progress !!!
	// and which phase we are in A / B etc
	float effect = GetEffectProgress();


	if (m_eZoomStyle == DXZS_OUT)
	{		
		if (m_nNumInputs == 2)
		{
			if (effect < 0.5)
			{
				effect *= 2.0f;
				effect = 1.0f - effect;

				pInSurf = InputSurface(0);
			}
			else
			{
				effect -= 0.5f;
				effect *= 2.0f;

				pInSurf = InputSurface(1);
			}
		}
		else
		{
			effect = 1.0f - effect;
			pInSurf = InputSurface(0);
		}


		float xscale = (float) WI.OutputBnds.Width() * effect;
		float yscale = (float) WI.OutputBnds.Height() * effect;

		RECT rect;
		rect.left = WI.OutputBnds.Left();
		rect.right = rect.left + (long) xscale;
		rect.top = WI.OutputBnds.Top();
		rect.bottom = rect.top + (long) yscale;
		CDXDBnds newbnd;
		newbnd.SetXYRect(rect);

		if (newbnd.Width() > 0 && newbnd.Height()>0)
			ZoomOut(newbnd, WI.OutputBnds, pInSurf);
	}
	else
	{
		if (m_nNumInputs == 2)
		{
			if (effect < 0.5)
			{
				effect *= 2.0f;
				effect = 1.0f - effect;

				pInSurf = InputSurface(0);
			}
			else
			{
				effect -= 0.5f;
				effect *= 2.0f;

				pInSurf = InputSurface(1);
			}
		}
		else
		{
			effect = 1.0f - effect;
			pInSurf = InputSurface(0);
		}

		long xscale =  (long) ((float) WI.DoBnds.Width() * effect);
		long yscale =  (long) ((float) WI.DoBnds.Height() * effect);


//		AndyTrace("xscale = %d  yscale = %d \n", xscale, yscale);
		RECT rect;
		rect.left = (long) (WI.DoBnds.Width() - xscale) / 2;
		rect.right = rect.left + (long) xscale;
//		rect.right = WI.DoBnds.Width() - rect.left;
		rect.top = (long) (WI.DoBnds.Height() - yscale) / 2 ;
		rect.bottom = rect.top + (long) yscale;
//		rect.bottom = WI.DoBnds.Height() - rect.top;
		CDXDBnds newbnd;
		newbnd.SetXYRect(rect);

		if (newbnd.Width() > 0 && newbnd.Height()>0)
			ZoomIn(newbnd, WI.OutputBnds, pInSurf);
	}


	return hr;
}


void CPandaZoom::ZoomIn(CDXDBnds bounds, CDXDBnds outbnd, IDXSurface* pInSurf)
{
    IDXTScale*		pScale      = NULL;
    IDXTransform*	pScaleTransform = NULL;
	HRESULT			hRes;
	CDXDVec			place;	
	SIZE			size;

	IDXSurface*				pOutSurf = OutputSurface();
//	DXFillSurface(pOutSurf, 0x00000000, FALSE, INFINITE);

	try
	{
		// Create and set-up the scale transform which will resize our image to fit
		// the entire window.  Use this instead of StretchBlt() to preserve
		// image quality as alpha is ignored with StretchBlt().
		hRes = m_pTransFact->CreateTransform(NULL, 0, NULL, 0, NULL, NULL, CLSID_DXTScale,
							IID_IDXTransform, (void**)&pScaleTransform);
		if(FAILED(hRes))
		{
			::MessageBox(NULL, TEXT("Failed to create the Scale transform!\n"
				"Please register dxtrans.dll."), TEXT("Vision Technician"), MB_OK);
			goto SCALEFAILED;
		}


		pScaleTransform->Setup(
							(IUnknown**) &pInSurf,     // Source (from LoadImage)
							1,
							(IUnknown**) &pOutSurf,    // Dest (from CreateSurface)
							1, 
							0);

		// Scaled-Image B
		// Get the IDXTScale interface because IDXTScale::ScaleFitToSize() 
		// is what we need to call.
		pScaleTransform->QueryInterface(IID_IDXTScale, (void**)&pScale);
		pScaleTransform->SetQuality(1.0);

		size.cx = outbnd.Width();
		size.cy = outbnd.Height();
		pScale->ScaleFitToSize(&bounds, size, TRUE);

		// Try to position it correctly in the center
		place[DXB_X] = outbnd.Left();
		place[DXB_Y] = outbnd.Top();


        DWORD dwFlags;
        pScaleTransform->GetMiscFlags(&dwFlags);
        dwFlags &= (~DXTMF_BLEND_WITH_OUTPUT);
        pScaleTransform->SetMiscFlags(dwFlags);


		// Scale the output surface to the window size.
		pScaleTransform->Execute(NULL, &bounds, &place);
	}
	catch(...)
	{

	}
	// Loose PreScale-Image A
SCALEFAILED:
    SAFE_RELEASE(pScale);
    SAFE_RELEASE(pScaleTransform);

}








void CPandaZoom::ZoomOut(CDXDBnds bounds, CDXDBnds outbnd, IDXSurface* pInSurf)
{
    IDXTScale*		pScale      = NULL;
    IDXTransform*	pScaleTransform = NULL;
	HRESULT			hRes;
	CDXDVec			place;	
	SIZE			size;
	
	IDXSurface*				pOutSurf = OutputSurface();
	DXFillSurface(pOutSurf, 0x00000000, FALSE, INFINITE);
	
	try
	{
		// Create and set-up the scale transform which will resize our image to fit
		// the entire window.  Use this instead of StretchBlt() to preserve
		// image quality as alpha is ignored with StretchBlt().
		hRes = m_pTransFact->CreateTransform(NULL, 0, NULL, 0, NULL, NULL, CLSID_DXTScale,
							IID_IDXTransform, (void**)&pScaleTransform);
		if(FAILED(hRes))
		{
			::MessageBox(NULL, TEXT("Failed to create the Scale transform!\n"
				"Please register dxtrans.dll."), TEXT("Vision Technician"), MB_OK);
			goto SCALEFAILED;
		}



		pScaleTransform->Setup(
							(IUnknown**) &pInSurf,     // Source (from LoadImage)
							1,
							(IUnknown**) &pOutSurf,    // Dest (from CreateSurface)
							1, 
							0);

		// Scaled-Image B
		// Get the IDXTScale interface because IDXTScale::ScaleFitToSize() 
		// is what we need to call.
		pScaleTransform->QueryInterface(IID_IDXTScale, (void**)&pScale);
		pScaleTransform->SetQuality(1.0);

		size.cx = bounds.Width();
		size.cy = bounds.Height();
		pScale->ScaleFitToSize(NULL, size, TRUE);

		// Try to position it correctly in the center
		place[DXB_X] = bounds.Left() + ((outbnd.Width() - bounds.Width()) / 2);
		place[DXB_Y] = bounds.Top() + ((outbnd.Height() - bounds.Height()) / 2);

/*        DWORD dwFlags;
        pScaleTransform->GetMiscFlags(&dwFlags);
        dwFlags &= (~DXTMF_BLEND_WITH_OUTPUT);
        pScaleTransform->SetMiscFlags(dwFlags);
*/
		// Scale the output surface to the window size.
		pScaleTransform->Execute(NULL, NULL, &place);
	}
	catch(...)
	{

	}
	// Loose PreScale-Image A
SCALEFAILED:
    SAFE_RELEASE(pScale);
    SAFE_RELEASE(pScaleTransform);

}


#ifdef _DEBUG

void AndyTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);

	::OutputDebugString(szBuffer);

	va_end(args);
}
#endif